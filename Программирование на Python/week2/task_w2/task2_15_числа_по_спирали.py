"""
Выведите таблицу размером n×n, заполненную числами от 1 до n^2 по спирали,
выходящей из левого верхнего угла и закрученной по часовой стрелке,
как показано в примере (здесь n=5):

Sample Input:
5

Sample Output:
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9

"""

N = int(input())
res = [[0 for j in range(N)] for i in range(N)]

for i in range(N):

	k = i if 2*i<N else N-i

	for j in range(k):
		res[i][j] = 4*j*(N-j-2)+4*N+(j-i)-3

	j = k
	while j<N-k:
		res[i][j] = 4*(N-i)*i+(j-i)+1  if 2*i<N  else 4*(N-i)*i+2*N-3*i-1-j
		j+=1

	j = N - k
	while j<N:
		res[i][j] =(4*(N-j)-1)*(j+1)+i-2*N
		j+=1

for row in res:
	print(*row)

"""

===============================================================

N = int(input())

m = [[0 for j in range(N)] for i in range(N)]

step = 0
num = 1
n = N

while step <= n:
    j = step
    i = step
    while j < n:
        m[i][j] = num
        num += 1
        j += 1

    num -= 1
    j = n - 1
    while i < n:
        m[i][j] = num
        num += 1
        i += 1

    num -= 1
    i = n - 1
    while j >= step:
        m[i][j] = num
        num+=1
        j-=1

    num -= 1
    j += 1
    while i > step:
        m[i][j] = num
        num+=1
        i -= 1

    step += 1
    n -= 1

print()
for i in range(0, N):
    print(*m[i])

===============================================================

N = int(input())

m = [[0 for j in range(N)] for i in range(N)]

step = 0
num = 1
n = N

while step < n:

    for j in range(step, n):
        i = step
        m[i][j] = num
        num += 1

    for i in range(step + 1, n):
        j = n - 1
        m[i][j] = num
        num += 1

    for j in range(n - 2, step - 1, -1):
        i = n - 1
        m[i][j] = num
        num += 1

    for i in range(n - 2, step, -1):
        j = step
        m[i][j] = num
        num += 1

    step += 1
    n -= 1

for i in range(0, N):
    print(*m[i])
    
===============================================================

n = int(input())
m = [[0]*n for i in range(n)]

if n % 2 != 0:
    center = n//2
    m[center][center] = n**2

num = 1
step = 0

while step < n:

    i = step
    j = step

    for x in range(step, n-1):
        m[i][j] = num
        num += 1
        j += 1

    for y in range(step, n-1):
        m[i][j] = num
        num += 1
        i += 1

    for x in range(n-1, step,  -1):
        m[i][j] = num
        num += 1
        j -= 1

    for y in range(n-1, step,  -1):
        m[i][j] = num
        num += 1
        i -= 1

    step += 1
    n -= 1

for i in m:
    print(*i)

===============================================================
===============================================================

n = int(input())
for i in range (n):
    for j in range(n):
        k = min (i, j, n - i - 1, n - j - 1)
        if i <= j:
            print (4 * k * (n - k) + j - k + i - k + 1, end = ' ')
        else:
            print (2 * (2 * (n - 2 * k) - 1) + 4 * k * (n - k) - (j - k + i - k + 1), end = ' ')
    print()

===============================================================

n = int(input())

# создаем массив n*n, заполненный нулями
a = [[0 for i in range(n)] for j in range(n)]

# создаем массив направлений движения
f = [[0, 1],[1, 0], [0, -1], [-1, 0]]

i = 0
j = 0
k = 0 # счетчик направления движения курсора

dir = f[k % 4] # вектор текущего движения курсора

for m in range(n**2):
    a[i][j] = m + 1
    
    # если курсор упирается в ненулевое значение ячейки массива,
    # то меняет направление движения на следующее в массиве направлений:
    if a[(i + dir[0]) % n][(j + dir[1]) % n] != 0:
        k += 1
        dir = f[k % 4]
    i += dir[0]
    j += dir[1]

# выводим массив
for i in range(len(a)):
    print(*a[i])

===============================================================

# Змея кружится и отворачивает от границ и ненулевых значений - прямо
# к центру, где её ждет конец. Направление закручивания легко поменять
# изменив 2 символа в коде. Подумайте где и каких, будет не сложно.
n = int(input())
x, y,  = 0, 0
dx, dy = 1, 0
a = [[0] * n for i in range(n)]

for i in range(n ** 2):
    a[y][x] = i + 1
    if not (0 <= x + dx < n) or not (0 <= y + dy < n) or a[y + dy][x + dx] != 0:
        dx, dy = -dy, dx
    x, y = x + dx, y + dy
for i in a:
    print(*i)

===============================================================

n = int(input())
# Переменной dx присваивается значение 1
# Переменной dy присваивается значение 0
# Обычно dx и dy - это некие приращения для переменных x и y
dx, dy = 1, 0
# Переменным x и y присваивается значение 0
x, y = 0, 0
# Создаётся список списков
# Это матрица n*n
# Пока все её элементы - пустые (None)
arr = [[None] * n for _ in range(n)]
# Выполняется перебор
# Для переменной i последовательно перебираем значения от 1 до (n-квадрат + 1)
for i in range(1, n**2+1):
	# Элементу матрицы с координатами x и y присваивается значение i
	# Эта строчка будет присваивать последовательные натуральные числа
	# тем ячейкам, которые перебирает код чуть ниже
	arr[x][y] = i
	# Создаются временные переменные nx и ny
	# в которых вычисляются новые значения для x и y
	# для этого к старым значенииям прибавляются приращения
	nx, ny = x+dx, y+dy
	# Если всё нормально, и индекс не выскочил за пределы матрицы
	# или не наткнулся на уже занятую ячейку
	if 0 <= nx < n and 0 <= ny < n and not arr[nx][ny]:
		# то эти значения и оставляются
		x, y = nx, ny
	else:
		# а если индекс выскочил за границу матрицы
		# или наткнулся на уже занятую ячейку
		# то разворачиваемся на 90 градусов
		# путем замены приращения по x и y друг на друга
		# а минус нужен, чтобы он не ходил только вправо или вниз,
		# а чередовал с движениями вверх или влево.
		# Так и получается спираль
		dx, dy = -dy, dx
		# и используем уже это изменённое движение для новых значений x и y
		x, y = x+dx, y+dy
# После того, как перебрали все элементы,
# печатаем то, что получилось
for x in list(zip(*arr)):
	print(*x)

===============================================================
===============================================================

n = int(input())
m = [[0]*n for i in range(n)]
k = 0
x = -1
y = 0
# x и y - это координаты массива, в которые
# в данный момент вносится значение.
# Изначально x задаётся равным -1 так как алгоритм
# сначала делает смещение, а потом вносит значение,
# и, чтобы попасть в точку [0][0] нужно начинать с
# координат [0][-1].
# Да, костыль. =)

for i in range(1, 2*n):
# При рисовке спирали со стороной n мы
# каждый раз рисуем ровно 2*n-1 рядов клеток,
# Теперь i - номер рисуемого ряда.

    for j in range(n - i//2):
# При этом в каждом ряду мы рисуем по n-i//2 клеток
#    То есть для n=5 мы рисуем:
#    1 ряд из 5 клеток вправо
#    2 ряд из 4 клеток вниз
#    3 ряд из 4 клеток влево
#    4 ряд из 3 клеток вверх
#    5 ряд из 3 клеток вправо
#    6 ряд из 2 клеток вниз
#    7 ряд из 2 клеток влево
#    8 ряд из 1 клетки вверх
#    9 ряд из 1 клетки вниз
# То есть если i % 2 == 1 мы движемся по x, в противном случае движемся по y,
# если i % 4 = 1 или 2, то координата растёт, в противном случае - убывает.
        if i % 2 == 1:
            x += 1 if (i % 4 == 1) or (i % 4 == 2) else -1
        else:
            y += 1 if (i % 4 == 1) or (i % 4 == 2) else -1
# Теперь, когда мы определили координату, вносим значение в массив
        k += 1
        m[y][x] = k
# Выводим массив
for i in range(n):
    [print(m[i][j], end=' ') for j in range(n)]
    print()


===============================================================================

n = int(input())
A = [[0 for i in range(n)] for j in range(n)]

i = 1
p = n // 2
k = 1

if n % 2 == 1:
    A[p][p] = int(n * n)

#Цикл по номеру витка
while k <= p:

    #Определение значений верхнего гор столбца
    j = k-1
    while j < n - k + 1:
        A[k-1][j] = i
        i += 1
        j += 1

    # --//-- По правому вертикальному столбцу
    j = k
    while j < n - k + 1:
        A[j][n-k] = i
        i += 1
        j += 1

    # --//-- по нижнему горизонтальному столбцу
    j = n - k - 1
    while j >= k - 1:
        A[n-k][j] = i
        i += 1
        j -= 1

    # --//-- по левому вертикальному столбцу
    j = n - k - 1
    while j>=k:
        A[j][k-1] = i
        i += 1
        j -= 1

    k += 1


for row in A:
    print(*row)

===============================================================================

#n - размерность матрицы n x n
#mat - результирующая матрица
#st - текущее значение-счетчик для записи в матрицу
#m - коеффициент, используемый для заполнения верхней
#матрицы последующих витков, т.к. одномерные матрицы
#следующих витков имеют меньше значений

n = int(input())
mat = [[0] * n for i in range(n)]
st, m = 1, 0

# значение центрального элемента матрицы
mat[n//2][n//2] = n*n

for v in range(n//2):
    #Заполнение верхней горизонтальной матрицы
    for i in range(n-m):
        mat[v][i+v] = st
        st += 1

    #Заполнение правой вертикальной матрицы
    for i in range(v+1, n-v):
        mat[i][-v-1] = st
        st += 1

    #Заполнение нижней горизонтальной матрицы
    for i in range(v+1, n-v):
        mat[-v-1][-i-1] = st
        st += 1

    #Заполнение левой вертикальной матрицы
    for i in range(v+1, n-(v+1)):
        mat[-i-1][v] = st
        st += 1

    m += 2

#Вывод результата на экран
for i in mat:
    print(*i)


"""